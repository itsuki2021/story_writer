from typing import Dict, List, Optional, Set, Tuple

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.messages import TextMessage
from autogen_agentchat.ui import Console
from autogen_core import CancellationToken
from autogen_core.models import ChatCompletionClient
from json_repair import repair_json
from loguru import logger

from story_writer.config import DEFAULT_MODEL_CLIENT
from story_writer.prompts import (COMPRESSOR_SYSTEM_PROMPT, COMPRESSOR_USER_PROMPT, REVISER_SYSTEM_PROMPT,
                                  REVISER_USER_PROMPT, WRITER_SYSTEM_PROMPT, WRITER_USER_PROMPT)
from story_writer.schemas import (ChapterText, CompressResult, Event, EventGraph, GeneratedPassage, RevisionResult,
                                  StoryPlan, SubEvent)


class CompressionAgent(AssistantAgent):
    """Compression agent"""

    def __init__(
        self,
        model_client: ChatCompletionClient,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(
            name='compression_agent',
            model_client=model_client,
            model_client_stream=True,
            system_message=COMPRESSOR_SYSTEM_PROMPT,
            *args,
            **kwargs,
        )

    def _parse_compress_result(self, compress_result_text: str) -> CompressResult:
        """Parse the compress result

        Args:
            compress_result_text (str): The text returned by the compress agent

        Returns:
            CompressResult: The parsed compress result
        """
        cr_obj = repair_json(compress_result_text, ensure_ascii=False, return_objects=True)
        try:
            return CompressResult.model_validate(cr_obj)
        except Exception as e:
            logger.warning(f"Error parsing compress result: {e}")
            return CompressResult(relevance_score=0, summary_text='Parse error')

    async def compress_story_history(
        self,
        premise: str,
        story_history: str,
        current_sub_event: SubEvent,
    ) -> CompressResult:
        """Compress story history

        Args:
            premise (str): Story premise
            story_history (str): The partial story history
            current_sub_event (SubEvent): Current sub-event

        Returns:
            CompressResult: Compressed story history
        """
        await self.on_reset(CancellationToken())
        task = COMPRESSOR_USER_PROMPT.format(
            premise=premise,
            story_history=story_history,
            current_sub_event=current_sub_event.model_dump_json(),
        )
        task_result = await Console(self.run_stream(task=task))
        assert isinstance(task_result.messages[-1], TextMessage)
        compress_result = self._parse_compress_result(task_result.messages[-1].content)
        return compress_result


class RevisionAgent(AssistantAgent):
    """Revision agent"""

    def __init__(
        self,
        model_client: ChatCompletionClient,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(
            name='revision_agent',
            model_client=model_client,
            model_client_stream=True,
            system_message=REVISER_SYSTEM_PROMPT,
            *args,
            **kwargs,
        )

    def _parse_revision_result(self, revision_result_text: str) -> RevisionResult:
        """Parse revision result

        Args:
            revision_result_text (str): Revision result text

        Returns:
            RevisionResult: RevisionResult object
        """
        rr_obj = repair_json(revision_result_text, ensure_ascii=False, return_objects=True)
        try:
            return RevisionResult.model_validate(rr_obj)
        except Exception as e:
            logger.warning(f"Failed to parse revision result: {e}")
            return RevisionResult(
                confidence=0.0,
                issues=[],
                revised_text='',
                suggestions='',
            )

    async def revise_raw_text(
        self,
        premise: str,
        event_graph: EventGraph,
        current_sub_event: SubEvent,
        context_summary_text: str,
        raw_text: str,
    ) -> RevisionResult:
        """Revise a passage based on the story plan, current sub-event, and raw text.

        Args:
            premise (str): The original premise of the story.
            event_graph (EventGraph): The original event graph generated by the Outline Agents.
            current_sub_event (SubEvent): The current sub-event being written
            context_summary_text (str): The summary of the context passed into the Writer Agent
            raw_text (str): The raw text generated by the Writer Agent

        Returns:
            RevisionResult: The revision result
        """
        await self.on_reset(CancellationToken())
        task = REVISER_USER_PROMPT.format(
            premise=premise,
            event_graph=event_graph.model_dump_json(),
            current_sub_event=current_sub_event.model_dump_json(),
            context_summary_text=context_summary_text,
            raw_text=raw_text,
        )
        task_result = await Console(self.run_stream(task=task))
        assert isinstance(task_result.messages[-1], TextMessage)
        revision_result = self._parse_revision_result(task_result.messages[-1].content)
        return revision_result


class WriterAgent(AssistantAgent):
    """Final writer agent"""

    def __init__(
        self,
        model_client: ChatCompletionClient,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(
            name='writer_agent',
            model_client=model_client,
            model_client_stream=True,
            system_message=WRITER_SYSTEM_PROMPT,
            *args,
            **kwargs,
        )

    async def generate_text(
        self,
        premise: str,
        context_summary_text: str,
        current_chapter: str,
        next_chapter: str,
        sub_event: SubEvent,
    ) -> str:
        """Generate a text that realizes the sub-event within the context summary.

        Args:
            premise (str): The premise of the story.
            context_summary_text (str): Context summary generated by the coordinator.
            current_chapter (str): The current chapter of the story.
            next_chapter (str): The next chapter of the story.
            sub_event (SubEvent): The sub-event to be realized.

        Returns:
            str: The generated text.
        """
        await self.on_reset(CancellationToken())
        task = WRITER_USER_PROMPT.format(
            premise=premise,
            context_summary_text=context_summary_text,
            current_chapter=current_chapter,
            next_chapter=next_chapter,
            sub_event=sub_event.model_dump_json(indent=2),
        )
        task_result = await Console(self.run_stream(task=task))
        assert isinstance(task_result.messages[-1], TextMessage)
        text = task_result.messages[-1].content
        return text


class WritingBuilder:

    def __init__(
        self,
        model_client: ChatCompletionClient = DEFAULT_MODEL_CLIENT,
    ):
        """Initialize the writing builder

        Args:
            model_client (ChatCompletionClient, optional): Model client. defaults to DEFAULT_MODEL_CLIENT
        """
        self.compress_agent = CompressionAgent(model_client=model_client)
        self.revision_agent = RevisionAgent(model_client=model_client)
        self.writer_agent = WriterAgent(model_client=model_client)

    def _find_relevent_context(
        self,
        sub_event_id: str,
        event_dict: Dict[str, Event],
        relation_dict: Dict[str, Set[str]],
        sub_event_dict: Dict[str, SubEvent],
        passage_dict: Dict[str, GeneratedPassage],
    ) -> str:
        """Find the relevant context for a sub-event

        Args:
            sub_event_id (str): The ID of the sub-event
            event_dict (Dict[str, Event]): The event dict
            relation_dict (Dict[str, Set[str]]): The relation dict
            sub_event_dict (Dict[str, SubEvent]): The sub-event dict
            passage_dict (Dict[str, GeneratedPassage]): The passage dict

        Returns:
            str: The relevant context for the sub-event
        """
        if sub_event_id not in sub_event_dict:
            logger.warning(f"Sub-event {sub_event_id} not found in sub_event_dict")
            return ''
        sub_event = sub_event_dict[sub_event_id]
        if sub_event.parent_event_id not in event_dict:
            logger.warning(f"Event {sub_event.parent_event_id} not found in event_dict")
            return ''

        parent_event = event_dict[sub_event.parent_event_id]
        context = [parent_event.model_dump_json()]
        # find all adjacent events
        for e_id in relation_dict[parent_event.event_id]:
            adj_event = event_dict[e_id]
            context.append(adj_event.model_dump_json())

        # find all sibling sub events
        for se_id, se in sub_event_dict.items():
            if se_id != sub_event_id and se.parent_event_id == parent_event.event_id:
                context.append(se.model_dump_json())
                # if sub event has a generated passage
                if se_id in passage_dict:
                    passage = passage_dict[se_id]
                    context.append(passage.model_dump_json())

        context = '\n'.join(context)
        return context

    async def build_story(self,
                          story_plan: StoryPlan,
                          chapter_range: Optional[Tuple[int, int]] = None) -> List[ChapterText]:
        # Create dictionary
        event_dict: Dict[str, Event] = {e.event_id: e for e in story_plan.event_graph.nodes}
        relation_dict: Dict[str, Set[str]] = {eid: set() for eid in event_dict.keys()}
        for edge in story_plan.event_graph.edges:
            relation_dict[edge.source_event_id].add(edge.target_event_id)
            relation_dict[edge.target_event_id].add(edge.source_event_id)
        sub_event_dict: Dict[str, SubEvent] = {se.sub_event_id: se for se in story_plan.sub_events}
        passage_dict: Dict[str, GeneratedPassage] = {}

        chapters = story_plan.chapters
        if chapter_range:
            chapters = [c for c in chapters if chapter_range[0] <= c.chapter_id <= chapter_range[1]]

        chapters_output: List[ChapterText] = []
        for ch_i, chapter in enumerate(chapters):
            chapter_passages: List[GeneratedPassage] = []
            logger.info(f"Generating passages for chapter {chapter.chapter_id} {chapter.title}")
            for sub_event_id in chapter.sub_event_ids:
                logger.info(f"Generating passages for sub-event {sub_event_id}")
                sub_event = sub_event_dict[sub_event_id]

                # 1. Compress the context for the sub-event
                story_history = self._find_relevent_context(
                    sub_event_id=sub_event_id,
                    event_dict=event_dict,
                    relation_dict=relation_dict,
                    sub_event_dict=sub_event_dict,
                    passage_dict=passage_dict,
                )
                compress_result = await self.compress_agent.compress_story_history(
                    premise=story_plan.premise,
                    story_history=story_history,
                    current_sub_event=sub_event,
                )

                # 2. Generate raw text
                raw_text = await self.writer_agent.generate_text(
                    premise=story_plan.premise,
                    context_summary_text=compress_result.summary_text,
                    current_chapter=chapter.title,
                    next_chapter=chapters[ch_i + 1].title if ch_i < len(chapters) - 1 else '(No more chapters)',
                    sub_event=sub_event,
                )

                # 3. Revise the passage
                revision_result = await self.revision_agent.revise_raw_text(
                    premise=story_plan.premise,
                    event_graph=story_plan.event_graph,
                    current_sub_event=sub_event,
                    context_summary_text=compress_result.summary_text,
                    raw_text=raw_text,
                )

                # 4. Save the sub-event passage
                passage = GeneratedPassage(
                    sub_event_id=sub_event.sub_event_id,
                    context_snapshot=compress_result,
                    raw_text=raw_text,
                    revision_result=revision_result,
                )
                passage_dict[sub_event.sub_event_id] = passage
                chapter_passages.append(passage)

            chapter_text = ChapterText(
                chapter_id=chapter.chapter_id,
                title=chapter.title,
                summary=chapter.summary,
                sub_event_ids=chapter.sub_event_ids,
                passages=chapter_passages,
            )
            chapters_output.append(chapter_text)
            logger.info(f"Generated {len(chapter_passages)} passages for chapter {chapter.chapter_id}")

        return chapters_output

from typing import List

from autogen_agentchat.agents import AssistantAgent
from autogen_agentchat.messages import TextMessage
from autogen_agentchat.ui import Console
from autogen_core import CancellationToken
from autogen_core.models import ChatCompletionClient
from json_repair import repair_json
from loguru import logger

from story_writer.config import DEFAULT_MODEL_CLIENT
from story_writer.prompts import (SUBTASKER_SYSTEM_PROMPT, SUBTASKER_USER_PROMPT, WEAVER_SYSTEM_PROMPT,
                                  WEAVER_USER_PROMPT)
from story_writer.schemas import EventGraph, StoryPlan, SubEvent
from story_writer.schemas.planning_schemas import Chapter


class SubTaskerAgent(AssistantAgent):
    """SubTaskerAgent to decompose events into sub-events"""

    def __init__(
        self,
        model_client: ChatCompletionClient,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(
            name='subtasker_agent',
            model_client=model_client,
            system_message=SUBTASKER_SYSTEM_PROMPT,
            *args,
            **kwargs,
        )

    def _parse_sub_event(self, subevent_text: str) -> List[SubEvent]:
        """Parses sub-event text into SubEvent objects.

        Args:
            subevent_text (str): The text output from the SubTasker agent.

        Returns:
            List[SubEvent]: A list of SubEvent objects.
        """
        subevent_obj_list = repair_json(subevent_text, ensure_ascii=False, return_objects=True)
        if not isinstance(subevent_obj_list, list):
            subevent_obj_list = [subevent_obj_list]
        sub_events = []
        for subevent_obj in subevent_obj_list:
            try:
                subevent = SubEvent.model_validate(subevent_obj)
                sub_events.append(subevent)
            except Exception as e:
                logger.warning(f"Failed to parse subevent: {e}")
        return sub_events

    async def generate_sub_events(self, premise: str, event_graph: EventGraph, target_event_id: str) -> List[SubEvent]:
        """Invokes the SubTasker agent to decompose an event into sub-events.

        Args:
            premise (str): The premise of the story.
            event_graph (EventGraph): The event graph containing the event to decompose.
            target_event_id (str): The ID of the event to decompose.

        Returns:
            List[SubEvent]: A list of sub-events generated by the SubTasker agent.
        """
        await self.on_reset(CancellationToken())
        task = SUBTASKER_USER_PROMPT.format(
            premise=premise,
            event_graph=event_graph.model_dump_json(indent=2),
            target_event_id=target_event_id,
        )
        task_result = await Console(self.run_stream(task=task))
        assert isinstance(task_result.messages[-1], TextMessage)
        sub_events = self._parse_sub_event(task_result.messages[-1].content)
        return sub_events


class WeaverAgent(AssistantAgent):
    """WeaverAgent to weave sub-events into chapters."""

    def __init__(
        self,
        model_client: ChatCompletionClient,
        *args,
        **kwargs,
    ) -> None:
        super().__init__(
            name='weaver_agent',
            model_client=model_client,
            system_message=WEAVER_SYSTEM_PROMPT,
            *args,
            **kwargs,
        )

    def _parse_chapters(self, chapter_text: str) -> List[Chapter]:
        """Parses chapter text into Chapter objects.

        Args:
            chapter_text (str): The text output from the Weaver agent.

        Returns:
            List[Chapter]: A list of Chapter objects.
        """
        chapter_obj_list = repair_json(chapter_text, ensure_ascii=False, return_objects=True)
        if not isinstance(chapter_obj_list, list):
            chapter_obj_list = [chapter_obj_list]
        chapters = []
        for chapter_obj in chapter_obj_list:
            try:
                chapter = Chapter.model_validate(chapter_obj)
                chapters.append(chapter)
            except Exception as e:
                logger.warning(f"Failed to parse chapter: {e}")
        return chapters

    async def generate_chapters(self, premise: str, event_graph: EventGraph,
                                sub_events: List[SubEvent]) -> List[Chapter]:
        """Invokes the Weaver agent to weave sub-events into a story plan.

        Args:
            premise (str): The story premise.
            event_graph (EventGraph): The event graph from the OutlineBuilder.
            sub_events (List[SubEvent]): All sub-events from the SubTasker.

        Returns:
            List[Chapter]: A list of Chapter objects.
        """
        await self.on_reset(CancellationToken())
        task = WEAVER_USER_PROMPT.format(
            premise=premise,
            event_graph=event_graph.model_dump_json(indent=2),
            sub_events='\n'.join([sub_event.model_dump_json() for sub_event in sub_events]),
        )
        task_result = await Console(self.run_stream(task=task))
        assert isinstance(task_result.messages[-1], TextMessage)
        chapters = self._parse_chapters(task_result.messages[-1].content)
        return chapters


class PlanningBuilder:

    def __init__(
        self,
        model_client: ChatCompletionClient = DEFAULT_MODEL_CLIENT,
    ):
        """
        Initializes the PlanningBuilder.

        Args:
            model_client (ChatCompletionClient, optional): The client for interacting with the language model.
        """
        self.subtasker_agent = SubTaskerAgent(model_client=model_client)
        self.weaver_agent = WeaverAgent(model_client=model_client)

    def _resolve_id_conflict(self, sub_event_list: List[SubEvent], sub_event: SubEvent) -> SubEvent:
        """Resolve sub event id conflict

        Args:
            sub_event_list (List[SubEvent]): List of sub events
            sub_event (SubEvent): Sub event

        Returns:
            SubEvent: Resolved sub event
        """
        seid = sub_event.sub_event_id
        sub_event_dict = {se.sub_event_id: se for se in sub_event_list}
        if seid in sub_event_dict:
            suffix = 1
            while f"{seid}_{suffix}" in sub_event_dict:
                suffix += 1
            sub_event.sub_event_id = f"{seid}_{suffix}"
        return sub_event

    async def build_plan(self, premise: str, event_graph: EventGraph) -> StoryPlan:
        """Orchestrates the full planning process.

        Args:
            premise (str): The story premise.
            event_graph (EventGraph): The event graph from the OutlineBuilder.

        Returns:
            StoryPlan: The complete story plan for the Writing Agents.
        """

        # 1. Decompose all events into sub-events
        logger.info('Decomposing all events into sub-events...')
        all_sub_events: List[SubEvent] = []
        for event_i, event in enumerate(event_graph.nodes):
            logger.info(f"Decomposing event: {event.event_id}({event_i + 1}/{len(event_graph.nodes)})")
            sub_events = await self.subtasker_agent.generate_sub_events(
                premise=premise,
                event_graph=event_graph,
                target_event_id=event.event_id,
            )
            for sub_event in sub_events:
                sub_event.parent_event_id = event.event_id
                sub_event = self._resolve_id_conflict(all_sub_events, sub_event)
                all_sub_events.append(sub_event)
        logger.info(f"Generated {len(all_sub_events)} sub-events")

        # 2. Weave sub-events into chapters
        logger.info('Weave sub-events into chapters...')
        chapters = await self.weaver_agent.generate_chapters(premise=premise,
                                                             event_graph=event_graph,
                                                             sub_events=all_sub_events)
        logger.info(f"Generated {len(chapters)} chapters")

        # 3. Assemble the final StoryPlan object
        story_plan = StoryPlan(event_graph=event_graph, sub_events=all_sub_events, chapters=chapters)
        return story_plan
